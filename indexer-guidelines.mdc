---
description: 
globs: indexers/*.ts,indexers/**/*.ts
alwaysApply: false
---
# Indexer Implementation Guidelines

## Overview

This document outlines the requirements and guarantees for implementing indexers in the FrostByte system. All indexers must adhere to these guidelines to ensure data consistency and proper integration.

## Requirements

### 1. Interface Compliance

Every indexer must implement the `Indexer` interface with the following methods:
- `initialize(): void` - Called when the indexer is initialized
- `indexBlocks(blocks: { block: LazyBlock, txs: LazyTx[], traces: LazyTraces | undefined }[]): void` - Processes a batch of blocks
- `registerRoutes(app: OpenAPIHono): void` - Registers HTTP endpoints for the indexer

### 2. Factory Function Export

Each indexer module must export a factory function of type `CreateIndexerFunction`:
```typescript
export type CreateIndexerFunction = (blocksDb: BlockDB, indexingDb: SQLite.Database) => Indexer;
```

Example:
```typescript
export default function createMyIndexer(blocksDb: BlockDB, indexingDb: SQLite.Database): Indexer {
    return new MyIndexer(blocksDb, indexingDb);
}
```

### 3. Batch Processing

- Data is delivered to indexers in chunks
- Each `indexBlocks()` call represents a complete database transaction
- All operations within a single `indexBlocks()` call are atomic

### 4. Error Handling

**Critical**: Never catch errors inside `indexBlocks()`. Let all errors bubble up to fail the entire batch. This ensures data consistency.

```typescript
// ❌ WRONG - Don't do this
indexBlocks(blocks) {
    try {
        // process blocks
    } catch (error) {
        console.error(error); // This will lead to inconsistent data!
    }
}

// ✅ CORRECT - Let errors propagate
indexBlocks(blocks) {
    // process blocks
    // any errors will automatically fail the entire batch
}
```

## Guarantees

### 1. Execution Guarantees

- You will not be interrupted mid-batch (the database transaction will complete or rollback entirely)
- No guarantees about indexer instance lifecycle
- No guarantees about when instances are created or destroyed

### 2. Block Ordering

Blocks are delivered in strict sequential order. You can rely on this ordering for any logic that depends on block sequence.

### 3. State Management

- Use class fields only for caching and optimization
- Do not use class fields for persistent data storage
- Treat every batch as if it's the last one before a reboot
- Ensure all important state is persisted to the database within each transaction

```typescript
class MyIndexer implements Indexer {
    // ✅ OK - Cache for optimization
    private cache = new Map<string, CachedData>();
    
    // ❌ WRONG - Don't store persistent data in memory
    private totalTransactions = 0; // This will be lost on restart!
    
    indexBlocks(blocks) {
        // ✅ CORRECT - Persist all data to database
        this.db.prepare('INSERT INTO stats (total_txs) VALUES (?)').run(txCount);
    }
}
```

## Best Practices

1. **Idempotency**: Design your indexer to handle re-processing of blocks gracefully
2. **Performance**: Use prepared statements and batch inserts for better performance
3. **Testing**: Test your indexer with various block scenarios including edge cases
4. **Monitoring**: Log important events but avoid excessive logging in production
